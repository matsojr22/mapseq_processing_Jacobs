import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.spatial.distance import jensenshannon
from scipy.stats import chi2_contingency
import ast
from itertools import combinations

# Set font to Helvetica
plt.rcParams["font.family"] = "Helvetica"

# File paths
file_paths = {
    "P12": "/Volumes/euiseokdataUCSC_3/Matt Jacobs/mapseq_analysis_adam/motif_analysis/P12_motif_percent_plot_data.csv",
    "P20": "/Volumes/euiseokdataUCSC_3/Matt Jacobs/mapseq_analysis_adam/motif_analysis/P20_motif_percent_plot_data.csv",
    "P60": "/Volumes/euiseokdataUCSC_3/Matt Jacobs/mapseq_analysis_adam/motif_analysis/P60_motif_percent_plot_data.csv",
}


def clean_motif_label(label):
    """Clean and standardize motif labels"""
    if isinstance(label, str):
        try:
            # Try to evaluate as a Python literal
            return str(sorted(ast.literal_eval(label)))
        except:
            # If that fails, just return the string
            return label
    return str(label)


def add_bracket_annotation(fig, ax, x_start, x_end, text):
    """Add an upward-opening bracket with text annotation below the x tick labels"""

    # Force a draw to ensure tick labels are rendered
    fig.canvas.draw()

    # Convert x positions to axis coordinates (0-1 range within the axis)
    xlim = ax.get_xlim()
    x_start_ax = (x_start - xlim[0]) / (xlim[1] - xlim[0])
    x_end_ax = (x_end - xlim[0]) / (xlim[1] - xlim[0])

    # Find the bottom of the tick labels by checking their bounding boxes
    tick_bottom = 0  # Start at axis bottom
    for tick in ax.get_xticklabels():
        if tick.get_text():  # Only consider non-empty labels
            bbox = tick.get_window_extent()
            # Convert to axes coordinates
            axes_coords = ax.transAxes.inverted().transform(
                [(bbox.x0, bbox.y0), (bbox.x1, bbox.y1)]
            )
            tick_y_bottom = axes_coords[0][
                1
            ]  # Bottom of tick label in axes coordinates
            tick_bottom = min(tick_bottom, tick_y_bottom)

    # Position brackets below the tick labels
    bracket_spacing = 0.02  # Small gap below tick labels
    bracket_height = 0.015  # Height of bracket
    text_spacing = 0.02  # Gap between bracket and text

    bracket_y = tick_bottom - bracket_spacing
    text_y = bracket_y - bracket_height - text_spacing

    # Draw bracket using plot with axes coordinates and clip_on=False
    # Left vertical line
    ax.plot(
        [x_start_ax, x_start_ax],
        [bracket_y, bracket_y + bracket_height],
        "k-",
        linewidth=1.5,
        transform=ax.transAxes,
        clip_on=False,
    )
    # Right vertical line
    ax.plot(
        [x_end_ax, x_end_ax],
        [bracket_y, bracket_y + bracket_height],
        "k-",
        linewidth=1.5,
        transform=ax.transAxes,
        clip_on=False,
    )
    # Bottom horizontal line
    ax.plot(
        [x_start_ax, x_end_ax],
        [bracket_y, bracket_y],
        "k-",
        linewidth=1.5,
        transform=ax.transAxes,
        clip_on=False,
    )

    # Add text below the bracket
    ax.text(
        (x_start_ax + x_end_ax) / 2,
        text_y,
        text,
        ha="center",
        va="top",
        fontsize=9,
        transform=ax.transAxes,
        clip_on=False,
    )


def calculate_distribution_jsd(freq_arrays):
    """Calculate JSD between three frequency distributions"""
    # Add small epsilon to avoid log(0) and normalize
    epsilon = 1e-10

    freq1 = np.array(freq_arrays[0]) + epsilon
    freq2 = np.array(freq_arrays[1]) + epsilon
    freq3 = np.array(freq_arrays[2]) + epsilon

    freq1 = freq1 / freq1.sum()
    freq2 = freq2 / freq2.sum()
    freq3 = freq3 / freq3.sum()

    # Calculate pairwise JSDs
    jsd_12 = jensenshannon(freq1, freq2)
    jsd_13 = jensenshannon(freq1, freq3)
    jsd_23 = jensenshannon(freq2, freq3)

    return jsd_12, jsd_13, jsd_23


# Read and process data
datasets = {}
all_motifs = set()

for name, path in file_paths.items():
    df = pd.read_csv(path)

    # Clean motif labels
    df["Motif_Label_Clean"] = df["Motif_Label"].apply(clean_motif_label)

    datasets[name] = df
    all_motifs.update(df["Motif_Label_Clean"].unique())

all_motifs = sorted(list(all_motifs))

# =============================================================================
# FIGURE 1: Global Normalization (each dataset sums to 1)
# =============================================================================

complete_data_global = []
for name, df in datasets.items():
    total_observations = df["Observed"].sum()

    for motif in all_motifs:
        motif_row = df[df["Motif_Label_Clean"] == motif]
        if len(motif_row) > 0:
            normalized_freq = motif_row["Observed"].iloc[0] / total_observations
            motif_count = motif_row["Motif_Count"].iloc[0]
        else:
            normalized_freq = 0.0
            motif_count = len(ast.literal_eval(motif)) if motif.startswith("[") else 1

        complete_data_global.append(
            {
                "Dataset": name,
                "Motif": motif,
                "Normalized_Freq": normalized_freq,
                "Motif_Count": motif_count,
            }
        )

plot_df_global = pd.DataFrame(complete_data_global)
plot_df_global_sorted = plot_df_global.sort_values(["Motif_Count", "Motif"])

# Create Figure 1 with reasonable height
fig1, ax1 = plt.subplots(figsize=(24, 8))

n_motifs = len(all_motifs)
x = np.arange(n_motifs)
width = 0.25

datasets_list = list(file_paths.keys())
colors = ["#1f77b4", "#ff7f0e", "#2ca02c"]

# Store bar objects to get actual positions
all_bars = []
for i, dataset in enumerate(datasets_list):
    dataset_data = plot_df_global_sorted[plot_df_global_sorted["Dataset"] == dataset]
    values = []
    for motif in plot_df_global_sorted["Motif"].unique():
        motif_data = dataset_data[dataset_data["Motif"] == motif]
        if len(motif_data) > 0:
            freq_values = list(motif_data["Normalized_Freq"])
            values.append(freq_values[0])
        else:
            values.append(0)

    bars = ax1.bar(
        x + i * width, values, width, label=dataset, color=colors[i], alpha=0.8
    )
    all_bars.extend(bars)

# Remove X axis label
ax1.set_ylabel("Normalized Frequency (Global)", fontsize=12)
ax1.set_title(
    "Motif Frequency Distribution - Global Normalization",
    fontsize=14,
    fontweight="bold",
)
ax1.set_xticks(x + width)
ax1.set_xticklabels(plot_df_global_sorted["Motif"].unique(), rotation=90, ha="center")
ax1.legend()

# Calculate global distribution JSD
global_freqs = []
unique_motifs = plot_df_global_sorted["Motif"].unique()
for dataset in datasets_list:
    dataset_freqs = []
    for motif in unique_motifs:
        filtered_data = plot_df_global_sorted[
            (plot_df_global_sorted["Dataset"] == dataset)
            & (plot_df_global_sorted["Motif"] == motif)
        ]
        freq_values = list(filtered_data["Normalized_Freq"])
        freq = freq_values[0]
        dataset_freqs.append(freq)
    global_freqs.append(dataset_freqs)

jsd_12, jsd_13, jsd_23 = calculate_distribution_jsd(global_freqs)

# Calculate bracket span from the actual x-axis range
# Use the x positions plus appropriate padding for full span
n_motifs = len(unique_motifs)
bracket_start = -width / 2  # Start from left edge of first group
bracket_end = n_motifs - 1 + 2.5 * width  # End at right edge of last group

jsd_text = f"P12-P20: {jsd_12:.3f}\nP12-P60: {jsd_13:.3f}\nP20-P60: {jsd_23:.3f}"
add_bracket_annotation(fig1, ax1, bracket_start, bracket_end, jsd_text)

# Remove manual bottom adjustment since bracket function handles this automatically
plt.tight_layout()
plt.show()

# =============================================================================
# FIGURE 2: Domain-wise Normalization (each motif length group sums to 1)
# =============================================================================

# Group motifs by count (domain)
motif_domains = {}
for motif in all_motifs:
    if motif.startswith("["):
        count = len(ast.literal_eval(motif))
    else:
        count = 1
    if count not in motif_domains:
        motif_domains[count] = []
    motif_domains[count].append(motif)

# Sort domains and motifs within domains
sorted_domains = sorted(motif_domains.keys())
domain_sorted_motifs = []
domain_boundaries = []
current_pos = 0

for domain in sorted_domains:
    domain_motifs = sorted(motif_domains[domain])
    domain_sorted_motifs.extend(domain_motifs)
    domain_boundaries.append(
        (current_pos, current_pos + len(domain_motifs) - 1, domain)
    )
    current_pos += len(domain_motifs)

# Calculate domain-wise normalized frequencies
complete_data_domain = []
for name, df in datasets.items():
    for domain in sorted_domains:
        domain_motifs = motif_domains[domain]
        # Calculate domain total across all datasets for this domain
        domain_total = 0
        for dataset_df in datasets.values():
            domain_total += dataset_df[
                dataset_df["Motif_Label_Clean"].isin(domain_motifs)
            ]["Observed"].sum()

        for motif in domain_motifs:
            motif_row = df[df["Motif_Label_Clean"] == motif]
            if len(motif_row) > 0:
                normalized_freq = (
                    motif_row["Observed"].iloc[0] / domain_total
                    if domain_total > 0
                    else 0
                )
                motif_count = motif_row["Motif_Count"].iloc[0]
            else:
                normalized_freq = 0.0
                motif_count = domain

            complete_data_domain.append(
                {
                    "Dataset": name,
                    "Motif": motif,
                    "Normalized_Freq": normalized_freq,
                    "Motif_Count": motif_count,
                    "Domain": domain,
                }
            )

plot_df_domain = pd.DataFrame(complete_data_domain)

# Create Figure 2 with reasonable height
fig2, ax2 = plt.subplots(figsize=(24, 8))

n_motifs_domain = len(domain_sorted_motifs)
x_domain = np.arange(n_motifs_domain)

# Store bar objects to get actual positions
all_bars_domain = []

for i, dataset in enumerate(datasets_list):
    values = []
    for motif in domain_sorted_motifs:
        dataset_data = plot_df_domain[
            (plot_df_domain["Dataset"] == dataset) & (plot_df_domain["Motif"] == motif)
        ]
        if len(dataset_data) > 0:
            freq_values = list(dataset_data["Normalized_Freq"])
            values.append(freq_values[0])
        else:
            values.append(0.0)

    bars = ax2.bar(
        x_domain + i * width, values, width, label=dataset, color=colors[i], alpha=0.8
    )
    all_bars_domain.extend(bars)

# Remove X axis label
ax2.set_ylabel("Normalized Frequency (Domain-wise)", fontsize=12)
ax2.set_title(
    "Motif Frequency Distribution - Domain-wise Normalization",
    fontsize=14,
    fontweight="bold",
)
ax2.set_xticks(x_domain + width)
ax2.set_xticklabels(domain_sorted_motifs, rotation=90, ha="center")
ax2.legend()

# Add domain separators
for i, (start, end, domain) in enumerate(domain_boundaries[:-1]):
    separator_x = end + 0.5 + width
    ax2.axvline(x=separator_x, color="red", linestyle="--", alpha=0.7)

# Calculate domain-wise JSDs and add brackets at the same level (without modifying y-limits)
for start, end, domain in domain_boundaries:
    # Get frequencies for this domain across all datasets
    domain_freqs = []
    domain_motifs = motif_domains[domain]

    for dataset in datasets_list:
        dataset_domain_freqs = []
        for motif in domain_motifs:
            filtered_data = plot_df_domain[
                (plot_df_domain["Dataset"] == dataset)
                & (plot_df_domain["Motif"] == motif)
            ]
            freq_values = list(filtered_data["Normalized_Freq"])
            freq = freq_values[0]
            dataset_domain_freqs.append(freq)
        domain_freqs.append(dataset_domain_freqs)

    # Calculate JSDs for this domain
    jsd_12, jsd_13, jsd_23 = calculate_distribution_jsd(domain_freqs)

    # Calculate bracket span using domain boundaries and actual bar layout
    # Get the actual x positions of bars for this domain
    first_motif_x = start  # x position of first motif in domain
    last_motif_x = end  # x position of last motif in domain

    # Calculate bracket span from leftmost bar edge to rightmost bar edge
    bracket_start = first_motif_x - width / 2  # Left edge of first bar group
    bracket_end = last_motif_x + width + width / 2  # Right edge of last bar group

    jsd_text = f"P12-P20: {jsd_12:.3f}\nP12-P60: {jsd_13:.3f}\nP20-P60: {jsd_23:.3f}"
    add_bracket_annotation(fig2, ax2, bracket_start, bracket_end, jsd_text)

# Remove manual bottom adjustment since bracket function handles this automatically
plt.tight_layout()
plt.show()

# =============================================================================
# STATISTICAL SUMMARY
# =============================================================================

print("\n" + "=" * 100)
print("COMPREHENSIVE STATISTICAL ANALYSIS")
print("=" * 100)

print("\n1. GLOBAL NORMALIZATION - Overall Distribution Comparison:")
print("-" * 80)
global_jsd_12, global_jsd_13, global_jsd_23 = calculate_distribution_jsd(global_freqs)
print(f"P12 vs P20: JSD = {global_jsd_12:.4f}")
print(f"P12 vs P60: JSD = {global_jsd_13:.4f}")
print(f"P20 vs P60: JSD = {global_jsd_23:.4f}")

print("\n2. DOMAIN-WISE NORMALIZATION - Domain-specific Comparisons Only:")
print("-" * 80)
print("(No global comparison - only within-domain comparisons are meaningful)")
for start, end, domain in domain_boundaries:
    domain_freqs = []
    domain_motifs = motif_domains[domain]

    for dataset in datasets_list:
        dataset_domain_freqs = []
        for motif in domain_motifs:
            filtered_data = plot_df_domain[
                (plot_df_domain["Dataset"] == dataset)
                & (plot_df_domain["Motif"] == motif)
            ]
            freq_values = list(filtered_data["Normalized_Freq"])
            freq = freq_values[0]
            dataset_domain_freqs.append(freq)
        domain_freqs.append(dataset_domain_freqs)

    domain_jsd_12, domain_jsd_13, domain_jsd_23 = calculate_distribution_jsd(
        domain_freqs
    )

    print(f"Domain {domain} ({len(domain_motifs)} motifs):")
    print(f"  P12 vs P20: JSD = {domain_jsd_12:.4f}")
    print(f"  P12 vs P60: JSD = {domain_jsd_13:.4f}")
    print(f"  P20 vs P60: JSD = {domain_jsd_23:.4f}")

print("\n3. DOMAIN COMPOSITION:")
print("-" * 80)
for domain in sorted_domains:
    motifs_in_domain = motif_domains[domain]
    print(f"Domain {domain}: {len(motifs_in_domain)} motifs")
    for motif in motifs_in_domain:
        print(f"  {motif}")

print("\n" + "=" * 100)
print("INTERPRETATION")
print("=" * 100)
print(
    "• Global Normalization: Compares entire frequency distributions across all motifs"
)
print(
    "• Domain-wise Normalization: Compares frequency distributions only within each motif complexity level"
)
print(
    "• JSD values: 0 = identical distributions, 1 = maximally different distributions"
)
print(
    "• Lower JSD = more similar temporal patterns, Higher JSD = more divergent temporal patterns"
)
print(
    "• Each domain represents motifs of the same complexity (number of brain regions involved)"
)
print("• Domain-wise analysis isolates complexity-specific developmental patterns")
